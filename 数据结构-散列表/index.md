# 数据结构:散列表

# 散列表是什么
散列表是一种`O(1)`复杂度查找的数据结构，它是如何做到的呢
* 数组的随机访问为`O(1)`
* 把数据的key通过某种方式(hash函数)转化为数组的下标

于是当你要寻找某个key时，只需要通过hash函数把你的值转化为数组的下标，通过下标直接访问数组即可得到你要找的数据。

# 散列函数
散列函数是把key转化为数组下标的函数，理想的函数需要满足以下三个条件:
* 散列函数计算得到的散列值是一个非负整数（这个值是数组的下标）
* 如果key1 = key2，那 hash(key1) = hash(key2)
* 如果key1 ≠ key2，那 hash(key1) ≠ hash(key2) `[这一条基本没有散列函数能做到，所以会产生散列冲突]`

# 散列冲突
上述散列函数需要满足的条件中`如果key1 ≠ key2，那 hash(key1) ≠ hash(key2)`很难被满足，所以就会出现`key1 ≠ key2，但是 hash(key1) = hash(key2)`的情况，这种情况叫散列冲突。这里给出常见的散列冲突解决方法：
## 开放寻址法
### 线性探测
 * 插入：某个key做完hash后发现对应下标的位置已经有值，则查找下一个下标处是否有值，直到寻找到一个空的位置。
 * 查找：先对key做hash，到它本该在的地方寻找，如果有则直接返回，否则依次查找下一个位置，直到找到(返回)或者找到空位(找不到)
 * 删除：不能直接把目的位置清空，否则会影响查找操作；需要把删除的位置标记为`deleted`

### 二次探测
和线性探测一致，只是查找步长不一样；线性探测步长一致是1，二次探测步长为：`1^2` `2^2` ...

### 双重散列
使用一堆散列函数，第一个找不到则用第二个，依次类推...

## 链表法
每个数组的位置都对应一个链表，插入时直接把数据附加到链表最后。这个是最简单也是最好用的办法

![链表法](/images/pasted-5.png)

# 工业级的散列表
## 要求
* 支持快速的查询、插入、删除操作
* 内存占用合理，不能浪费过多空间
* 性能稳定，在极端情况下，性能也不能退化到无法接受的情况

## 需要考虑的点
### 设计一个合适的散列函数
* 尽可能的随机、均匀，避免散列冲突
* 保持散列函数简单
* 常见方法：直接寻址法、平方取中法、折叠法、随机数法

### 定义装载因子阈值，并设计动态扩容策略
#### 如何设置装载因子阈值？
* 该阈值主要用来控制扩容&缩容，时间复杂度分析用摊还分析法
* 需要根据业务权衡时间复杂度和空间复杂度

#### 如何避免低效扩容？
分批扩容，和基本扩容方式相比，每次插入时顺带完成一次扩容中一条数据的迁移，避免达到阈值后一次需要O(n)的时间来完成整体扩容。
* 插入：将数据插入散列表，并从老的散列表中拿出一个数据放入新的散列表
* 查询：先查新散列表，再查老散列表

### 选择合适的散列冲突解决方法
开放寻址法和链表法的优劣分析，考虑以下情况：
* 当要存储的数据较小，链表法因为需要存储指针，可能造成较大的空间浪费。
* 当装载因子较大时，开放寻址法的性能退化严重(扩容缩容耗时&寻址耗时)
* 当数据规模较大，开放寻址法因为需要连续的内存空间，可能会导致内存无法利用
* 链表不需要连续的内存空间，对cpu缓存不友好

所以大部分情况下，链表法更加普适，当链表较大时可以改造为红黑树或跳表来避免性能恶化；而开放寻址法更适合小规模数据、装载因子不高的情况。

# 散列表和链表/跳表一起使用
数组有随机访问的优势，但有占据连续内存的优势的缺点。
链表具有可不连续存储的优势，但有访问查找需要线性级时间的缺点。
把数组(散列表)和链表(跳表)结合使用，可以结合两者的优势。

举例：散列表+双向链表的形式，prev和next用于指向真正链表的前序和后续；hnext用于组织散列表的拉链，这样插入、删除、查找的复杂度都降低到了`O(1)`

![散列表+双向链表](/images/pasted-6.png)


