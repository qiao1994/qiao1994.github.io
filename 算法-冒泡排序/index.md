# 算法:冒泡排序

# 基本原理
一次冒泡的定义：从左往右遍历一次数组，比较每个元素和它后面元素的大小，如果后面的元素较小则交换两者。
每次冒泡会把一个元素移动到它应该在的位置(例:第一次冒泡会让最大的数据冒泡到最后)，冒泡排序最多执行n次冒泡,能使得所有元素有序

# 优化过程
### 冒泡遍历元素数量
* 原：每次冒泡都会遍历所有元素
* 新：从第二次冒泡开始,遍历的元素逐渐减少(每次冒泡减少一个)；因为每次遍历都会让一个数据到达它应该在的位置,即它的位置在后续的冒泡中不会再发生变化，所以后续的冒泡可以不遍历该元素。

### 数据本身不是完全逆序,可能不需要完成所有的冒泡
增加标志位`$flag`，如果上一次冒泡没有发生交换，则表名数据已经有序,不再进行冒泡，直接返回。


# 代码

```
<?php
    $arr = [4, 5, 6, 3, 2, 1];
    puppleSort($arr);
    /**
     * 冒泡排序
     * 一次冒泡的定义:从左往右遍历一次数组,比较每个元素和它后面元素的大小,如果后面的元素较小,则交换两者
     * 每次冒泡会把一个元素移动到它应该在的位置,最多执行n次冒泡,所有元素有序
     * @param array $arr
     * @return array $arr 有序数组
     */
    function puppleSort($arr) {
        $n = count($arr);
        $flag = true;
        for ($i = $n - 1; $i > 0; $i--) { //每次需要比较的元素都在变少,每次冒泡需要遍历从0到$i,比较每个元素与后者的大小
            $flag = false;
            for ($j = 0; $j < $i; $j++) { //遍历从0到$i,看相邻的两个元素是否需要交换
                if ($arr[$j] > $arr[$j+1]) {
                    $flag = true;
                    swap($arr, $j, $j+1); 
                }
            }
            if (!$flag) {
                break;
            }
            echo '本次冒泡使得下标' . $i . '位的数据准确:';
            echo implode(',', $arr) . PHP_EOL;
        }
        return $arr;
    }

    /**
     * 交换操作,把数组中下标为$i和$j的数据换位置
     * @param array $arr
     * @param integer $i
     * @param integer $j
     */
    function swap(&$arr, $i, $j) {
        $temp = $arr[$i];
        $arr[$i] = $arr[$j];
        $arr[$j] = $temp;
    }

```

# 执行结果

```
本次冒泡使得下标5位的数据正确:4,5,3,2,1,6
本次冒泡使得下标4位的数据正确:4,3,2,1,5,6
本次冒泡使得下标3位的数据正确:3,2,1,4,5,6
本次冒泡使得下标2位的数据正确:2,1,3,4,5,6
本次冒泡使得下标1位的数据正确:1,2,3,4,5,6
```
