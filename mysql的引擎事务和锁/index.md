# MySQL的引擎、事务和锁

# 存储引擎对比

|    项    | MyISAM                 | innodb                                         |
| :------: | :--------------------- | ---------------------------------------------- |
| 事务支持 | 否                     | 是                                             |
| 全文索引 | 是                     | 否（可以通过sphinx实现）                       |
|    锁    | 表级，优先处理写入     | 行级（只在where是主键查询时可以实现）          |
| 出现死锁 | 否                     | 是（解决方式是将持有最少行级排它锁的事务回滚） |
|   外键   | 否                     | 是                                             |
| 优势操作 | count、大量instert操作 | 根据主键查询、高并发写入                       |
| 存储结构 | 堆表、三个文件         | 索引组织表、一个文件                           |
| 存储空间 | 可压缩                 | 较大                                           |
| 可移植性 | 文件形式               | 数据文件/binlog/mysqldump                      |

# 事务

## 性质

ACID（原子性、一致性、隔离性、持久性）

## 并发问题

并发问题，这里假设A和B都是事务

- 脏读：A读到了B更新的数据，然后B回滚，A脏读了
- 不可重复读（侧重修改）：A多次读取同一记录，B在A读取的过程中，对数据做了更新并提交，导致A多次读取不一致
- 幻读（侧重新增/删除）：A修改了每一行的内容，B新增了一条数据，A幻读

不同隔离级别的事务可以规避不同数量的并发问题。

## 实现方式

通过记录binlog

# 锁

## 数据库锁

参考：<https://www.cnblogs.com/xzwblog/p/6956817.html>

## 乐观锁和悲观锁

### 乐观锁

#### version实现

在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

####cas实现

即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

### 悲观锁

总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁。


