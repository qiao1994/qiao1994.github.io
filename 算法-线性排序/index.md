# 算法:线性排序

线性排序即排序时间复杂度为线性O(n)的排序
# 桶排序
## 数据要求
能够划分为m个有序的桶，且n个数据能够均匀地分配到m个桶中
## 基本思路
N个数据均匀地分布到从小到大的M个桶里，桶与桶之间有序，每个桶内的数据有序。
## 时间复杂度是O(n)
如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(klogk)。m 个桶排序的时间复杂度就是 O(mklogk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(nlog(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
## 适合场景
桶排序适合外部排序，即数据量非常大，无法一次取到内存中的情况

# 记数排序
## 数据要求
数据范围不大
## 基本思路
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内存储对应值的数量，省掉了桶内排序的时间。
## 优化思路
计数排序的桶`C[k]`里可以存储数值为k的数值个数，也存储小于等于k的值个数，这样在某些场景下会更加快速。
## 适合场景
计数排序适合数据范围不大的情况，比如人的年龄，高考分数等

# 基数排序
## 数据要求

* 需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
* 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

## 基本思路
假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。
先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。
## 优化思路
根据每一位来排序，我们可以用桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。
## 适合场景
可以分割出独立的“位”来比较，而且位之间有递进的关系
