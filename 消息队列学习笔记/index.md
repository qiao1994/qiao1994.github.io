# 消息队列学习笔记


## 为啥需要消息队列？

* 异步
* 削峰
* 解耦
* 数据一致性（非典型场景）

## 如何选择消息队列？

| 消息队列 | 优势                                              | 劣势                                                         | 备注                 |
| -------- | ------------------------------------------------- | ------------------------------------------------------------ | -------------------- |
| RabbitMQ | * 轻量<br />* Exchange模块支持路由配置            | * 对消息堆积不友好<br />* 性能差<br />* 用Erlang开发，难以二次开发 | 适合轻量场景         |
| RocketMQ | * 性能好,响应快<br />* 稳定可靠，有活跃的中文社区 | * 国内项目，影响力不足，兼容性较差                           | 适合在线场景         |
| Kafka    | * 总体吞吐高<br />                                | * 当消息不太多时，延迟高                                     | 适合日志类大数据场景 |

## 消息模型

### 队列模型

这是最朴素的模型，生产者生产消息放入队列，消费者按顺序逐个消费。

这种模型存在一个局限，如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就满足不了需求。

![img](https://static001.geekbang.org/resource/image/b1/84/b18f43f67ae1b0d24d88f0ba39708a84.jpg)

### 发布-订阅模型

这种模型解决了一份消息数据能不能被消费多次的问题

![img](https://static001.geekbang.org/resource/image/d5/54/d5c0742113b2a6f5a419e1ffc3327354.jpg)

### RabbitMQ 的消息模型

RabbitMQ依然坚持使用队列模型的产品之一，通过Exchange解决多个消费者的问题：在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。

![img](https://static001.geekbang.org/resource/image/2d/a5/2df04ce80ff54702240df8598f277ca5.jpg)

### RocketMQ 的消息模型

为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。

#### 主题

**每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费**。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。

#### 消费

订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。

消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。

#### 消费位置

在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。

![img](https://static001.geekbang.org/resource/image/46/17/465142ab5b5096f283118c307e8cc117.jpg)

### Kafka 的消息模型

与RocketMQ完全一致，。唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”

## 如何利用事务消息实现分布式事务？

### 需要事务的场景

订单提交时，清空购物车这件事不属于订单的主要逻辑，为了降低订单系统的压力与复杂度，可以放入消息队列异步执行。

![img](https://static001.geekbang.org/resource/image/d6/00/d6efbd1a48cb0d1cd352587f233c2500.jpg)

### 消息队列的解决方案

这时就存在一个问题，即如何确保“提交订单”与“清空购物车”这两件事的原子性（要么都成功，要么都失败），Kafka 和 RocketMQ 提供了事务相关功能，基本逻辑如下图所示：（其中“半消息”指未收到“提交”指令前，消费者无法读取到的消息）

![img](https://static001.geekbang.org/resource/image/27/e6/27ebf12e0dc79e00e1e42c8ff0f4e2e6.jpg)

这其中依然存在一个问题，如果前三步都成功了，第四步失败了，或者即将执行第四步时系统宕机了怎么办，对此，Kafka没有进行特殊处理，RocketMQ给出了“事务反查”的解决方案：如果订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。

## 如何确保消息不会丢失?

### 监测消息丢失的方法

发消息时增加自增ID信息，通过检查消费者处的消息是否递增来监测消息是否有丢失。有以下几个小点需要注意：

* 大多数消息队列的客户端都支持拦截器机制，可以利用拦截器机制，避免对业务代码的入侵
* Kafka 和 RocketMQ 不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性
* Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性

### 确保消息可靠传递

一条消息从生产到消费完成这个过程，可以划分三个阶段，对于每个阶段，都有需要注意的点。

![img](https://static001.geekbang.org/resource/image/81/05/81a01f5218614efea2838b0808709205.jpg)

* 生产阶段：需要捕获消息发送的错误（同步&异步场景都需要），并重发消息
* 存储阶段：可以通过配置刷盘（同步刷盘，先写磁盘，后返回ACK）和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失
* 消费阶段：需要在处理完全部消费业务逻辑之后，再发送消费确认

### 如何处理消费过程中的重复消息？

#### 消息重复的情况必然存在

在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：

* At most once: 至多一次，会有数据少量丢失
* At least once: 至少一次，会有少量重复消息出现；大多数消息队列都是这个级别
* Exactly once：恰好一次

#### 用幂等性解决重复消息问题

一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。有如下几种常用的设计幂等操作的方法：

* 利用数据库的唯一约束实现幂等：如`INSERT IF NOT EXIST`
* 为更新的数据设置前置条件：给数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新
* 记录并检查操作：也称为“Token 机制或者 GUID（全局唯一 ID）机制”，在执行数据更新操作之前，先检查一下是否执行过这个更新操作（分布式场景实现起来会比较复杂）

## 消息积压了该如何处理？

### 发送端性能优化

大多数情况，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能。

### 消费端性能优化

* 在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行
* 在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。因为对于消费者来说，在每个分区上实际上只能支持单线程消费。
* 注意：不要在消费端不真正消费就返回ACK，这样会丢消息



参考资料：https://time.geekbang.org/column/intro/100032301?tab=catalog

