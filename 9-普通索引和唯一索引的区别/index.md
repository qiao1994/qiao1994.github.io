# 9.普通索引和唯一索引的区别

### 查询过程

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

差异很小

### change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。

### 啥索引能用change buffer？

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

只有普通索引能使用change buffer

### 插入一条新记录的流程

* 这个记录要更新的目标页在内存中
  * 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；
  * 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。
* 这个记录要更新的目标页不在内存中
  * 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
  * **对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。**

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

### change buffer的使用场景

* 写多读少，change buffer收效更高
  * 会积攒很多修改到change buffer里，再统一merge

* 写少读多，不适合用change buffer
  * 刚写入一条修改到change buffer里，就执行读请求，马上需要执行merge，无收益且需要维护change buffer

### change buffer 和 redo log

redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。
