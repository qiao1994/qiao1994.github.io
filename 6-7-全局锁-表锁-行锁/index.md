# 6&7.全局锁、表锁、行锁

## 全局锁

### 命令

`Flush tables with read lock`

### 阻塞语句

* 数据更新语句（数据的增删改）
* 数据定义语句（包括建表、修改表结构等）
* 更新类事务的提交语句

### 使用场景

做全库逻辑备份

### 不加锁会有什么问题

不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

### mysqldump –single-transaction

当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图

使用这个需要引擎支持事务才可以。

## 表锁

### 命令

 `lock tables … read/write`

`unlock tables`

### MDL metadata lock

在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

#### MDL的坑

修改表结构时，会扫描全表数据，所以我们不会贸然修改服务中的大表的结构；但是修改高频查询的小表的结构也要小心，如下图所示，sessionD以后到达的查询请求都会被阻塞。

![MDL问题](https://qiao1994.github.io/images/MySQL/mdl-error.jpg)

## 行锁

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这个就是两阶段锁协议。

启示：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放

### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁

#### 策略

* 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。

* 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

  > 死锁检测会带来额外的负担，即每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作，其中n是要更新这一行的并发度。这个问题有如下解决方案：

  * 业务逻辑保证一定不会出现死锁，关闭死锁检测

  * 控制并发度

    * 在客户端控制  不行，因为客户端很多，单个数量可控，但是依然无法控制总数量。
    * 在数据库服务端控制，中间件、或者直接修改MySQL源码

  * 一行改成逻辑上的多行来减少锁冲突

    > 以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。






